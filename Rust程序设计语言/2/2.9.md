通常情况下,`if/else`无法满足需求,因为大于2种选择的情况比比皆是.另外,`else`条件的处理也可能变得及其复杂,那么有什么解决的办法吗?

Rust提供了`match`表达式,你可以用它替换复杂的`if/else`语句,并将条件处理组织得更加合理:

    let x = 5;
    
    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        4 => println!("four"),
        5 => println!("five"),
        _ => println!("something else"),
    }
    
match需要一个表达式作为输入,然后根据表达式的值执行不同的分支.match中的每个分支都是这样的形式:`val => expression`.当值被匹配,其对应分支的表达式就会被求值.match就得名于模式匹配.

那么,match的最大优势在哪?首先,match会强制检测是否能匹配输入值的所有情况.注意到最后一个分支了吗,没错就是(_).如果我们将这样移除,Rust会给我们一个错误提示:

    error: non-exhaustive patterns: `_` not covered
    
也就是说,Rust在尝试告诉我们遗漏了对某些值的处理.因为x是整型的,Rust检测到我们遗漏了对某些值的处理,例如6.如果没有`_`那么就会出现某些值没有相应的匹配，因此,Rust会拒绝编译我们的代码.`_`就像一个匹配所有其它值的分支.如果没有任何一个分支可以匹配,那么就会匹配`_`分支.正因为上面的代码有`_`匹配的处理,
对于x的任何值我们都有了处理分支,所以代码可以成功的编译.

match也可以处理枚举类型的匹配.还记的在上一节中介绍枚举的代码吗:

    use std::cmp::Ordering;
    
    fn cmp(a: i32, b: i32) -> Ordering {
        if a < b { Ordering::Less }
        else if a > b { Ordering::Greater }
        else { Ordering::Equal }
    }
    
    fn main() {
        let x = 5;
        let y = 10;
    
        let ordering = cmp(x, y);
    
        if ordering == Ordering::Less {
            println!("less");
        } else if ordering == Ordering::Greater {
            println!("greater");
        } else if ordering == Ordering::Equal {
            println!("equal");
        }
    }
    
我们可以使用match将这段代码改写如下:

    use std::cmp::Ordering;
    
    fn cmp(a: i32, b: i32) -> Ordering {
        if a < b { Ordering::Less }
        else if a > b { Ordering::Greater }
        else { Ordering::Equal }
    }
    
    fn main() {
        let x = 5;
        let y = 10;
    
        match cmp(x, y) {
            Ordering::Less => println!("less"),
            Ordering::Greater => println!("greater"),
            Ordering::Equal => println!("equal"),
        }
    }
    
这个版本显得清晰多了,而且还会检查是否对Ordering的所有可取值都有正确的匹配.在`if/else`版本中,如果我们遗漏了对`Greater`的处理,编译器一样会很高兴的为我们编译代码.但在match版本中,则无法通过编译.

match表达式允许你提取枚举中的值:

    enum OptionalInt {
        Value(i32),
        Missing,
    }
    
    fn main() {
        let x = OptionalInt::Value(5);
        let y = OptionalInt::Missing;
    
        match x {
            OptionalInt::Value(n) => println!("x is {}", n),
            OptionalInt::Missing => println!("x is missing!"),
        }
    
        match y {
            OptionalInt::Value(n) => println!("y is {}", n),
            OptionalInt::Missing => println!("y is missing!"),
        }
    }
    
match和枚举的结合,还可以用来做错误处理.例如,一个函数返回i32值,但在出现异常的情况下则无法做这样的保证.在这种情况下,我们可以让函数返回`OptionalInt`,并用match来处理返回值.

这里再次强调,match是一个表达式,这意味着它会返回值.所以我们可以将它放在let语句的右边或者直接将它放在其它表达式的内部.我们也可以将上面的例子改写如下:

    use std::cmp::Ordering;
    
    fn cmp(a: i32, b: i32) -> Ordering {
        if a < b { Ordering::Less }
        else if a > b { Ordering::Greater }
        else { Ordering::Equal }
    }
    
    fn main() {
        let x = 5;
        let y = 10;
    
        println!("{}", match cmp(x, y) {
            Ordering::Less => "less",
            Ordering::Greater => "greater",
            Ordering::Equal => "equal",
        });
    }                         