到目前为止,只剩下最后一种Rust语言的基本结构我们还没有介绍过,那就是循环.Rust中有两种循环结构:for和while.

##for

for用于执行一定次数的循环.Rust中的for循环与其它系统语言中的有一定差别.Rust的for循环看上去与以下C风格的for循环不一样:

    for (x = 0; x < 10; x++) {
        printf( "%d\n", x );
    }
    
在Rust中是这样的:

    for x in 0..10 {
        println!("{}", x); // x: i32
    }
    
总体上for循环在Rust中有如下抽象形式:

    for var in expression {
        code
    }
    
其中expression是一个迭代器,我们将会在后面的章节中做更深入的讨论.迭代器会返回一系列的元素.每个元素在循环中被迭代一次.元素的值被绑定到名字var,这个名字在循环体中可以被访问.当循环体执行完毕,从迭代器中提取另一个元素并执行另一轮的循环.当迭代器中没有元素了,for循环结束.

在我们的示例中,`0..10`是一个表达式,它给出了起始和终止位置,返回一个迭代器.需要注意的是上界10不被包含其中.所以循环打印0到9而没有10.

Rust是有意不提供C风格的for循环.即使对于经验丰富的C开发者来说,手工控制迭代元素是复杂且容易出错的.

当我们介绍迭代器的时候会再回过头来继续介绍for循环.

##while

Rust中的另一种循环结构是while循环,它看上去是这样的:

    let mut x = 5; // mut x: u32
    let mut done = false; // mut done: bool
    
    while !done {
        x += x - 3;
        println!("{}", x);
        if x % 5 == 0 { done = true; }
    }
    
当你不确定循环要执行的次数时,while是正确的选择.

如果你需要一个无限循环,你可以写成这样:

    while true {
    
Rust还提供了另外一个关键字loop处理这样的情况:

    loop {
    
Rust的控制分析将`loop`与`while true`区分成不同的结构,因为我们知道这是一个无限循环.虽然在目前阶段我们没必要去在细节上理解到底有什么不同.但通常来说,我们给编译器提供更多的信息可以帮助编译器产生更安全高效的代码.因此,如果你需要无限循环请优先使用loop.

##提前终止循环

让我们回顾一下先前的while循环代码:

    let mut x = 5;
    let mut done = false;
    
    while !done {
        x += x - 3;
        println!("{}", x);
        if x % 5 == 0 { done = true; }
    }
    
我们使用了一个done变量用于控制循环何时终止.Rust提供了两个关键字`break`和`continue`用于改变循环的迭代过程.

在先前的示例中,我们可以使用break改写如下:

    let mut x = 5;
    
    loop {
        x += x - 3;
        println!("{}", x);
        if x % 5 == 0 { break; }
    }                     
    
现在我们用loop来做循环并且通过break提前中循环中退出.

continue类似,但它不是终止循环,而是使得进入下一轮的迭代.以下代码用于打印奇数:

    for x in 0u32..10 {
        if x % 2 == 0 { continue; }
    
        println!("{}", x);
    }

continue和break可以在while和for循环中使用.
        