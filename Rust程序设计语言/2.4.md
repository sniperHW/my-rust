我们首先要学习的是变量绑定.看如下代码片段:

    fn main() {
        let x = 5;
    }
    
在每段示例中都放置`fn main() {`显得有点枯燥,所以我在将来的例子中我将把它去掉.当你将代码片段输入到你的源文件中时请确保加上`main()`,否则你将会得到一个编译错误.

在其它语言中这被称为变量.但Rust的变量绑定有很多小窍门.Rust支持一种非常强大的被称为模式匹配的特性,我们将会在后面继续讨论模式匹配.let表达式的左边不仅仅是一个变量名,而是一个完整的模式.这意味着我们可以写出下面这样的代码:

    let (x, y) = (1, 2);
    
当这个表达式被求值之后,x是1而y是2.模式非常强大,但目前为止我们所能做的只有这些.现在让我们暂时把它放在脑后,继续学习变量绑定.

Rust是一种静态类型语言,这意味着我们必须为变量指定类型.那么,为何我们先前的代码能通过编译?Rust将此称之为类型推导.如果它可以推断出变量的真实类型那么就无须我们去实际指定.

我们可以通过在变量名后面添加`:`来指定类型:
    
    let x: i32 = 5;
    
如果我让你把这段代码向同班同学大声念出来,你应该这么念,"x被绑定为i32类型,它的值是5".

在将来的示例中,我会把类型提示添加在注释中.例如下面这样:    

    fn main() {
        let x = 5; // x: i32
    }         
    
请注意这段提示与let语法的区别.包含这样的注释并不符合Rust的语言习惯.但我偶尔会加入这样的注释以帮助你更好的理解Rust的类型推导.

默认情况下,绑定是不可变的.以下代码将无法通过编译:

    let x = 5;
    x = 10;
    
错误提示如下:

    error: re-assignment of immutable variable `x`
         x = 10;
         ^~~~~~~
         
如果你需要改变绑定变量的值,你必须使用mut关键字:

    let mut x = 5; // mut x: i32
    x = 10;                     
    
让绑定默认不可变的答案不唯一,其中之一是Rust的主要关注点:安全性.如果你忘记对一个变量声明mut,那么当你改变一个变量的时候编译器就会捕捉到这个错误,提醒改变了某些你可能不期望能被改变的变量.如果默认是可变的,那么编译器将无法帮你发现类似的问题.如果你确实需要改变那个变量,那么为它添加mut就是了.

    